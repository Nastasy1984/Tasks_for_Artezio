В настоящее время я в основном разрабатываю приложения на JAVA в рамках обучения,
поэтому все нижеизложенное относится к разработке приложений на Java.

При разработке приложения я использую НАСЛЕДОВАНИЕ еще на этапе проектирования.
Перед началом написани кода я  на листе бумаги создаю предварительную иерархию
наследования классов, прописываю: 
- какие классы будут абстрактными (т.е. мне не нужно будет в дальнейшем создавать их экземпляры, 
тем не менее они будут содержать общие для классов-наследников переменные и методы,
 а также методы, которые могут быть переопределены в классах наследниках);
- какие дополнительные переменные и методы появятся у классов-наследников, расширяющих
родительский класс.

Я также использую наследование при необходимости добавить новый функционал в существующий 
конкретный класс (расширить его), когда при этом нужно сохранить возможность создания экземпляра класса родителя
(без дополненного функционала).

Наследование помогает мне избавится от повторного написания одного и того же кода, а значит:
- уменьшает вероятность ошибок;
- сокращает время разработки и объем кода (улучшает качество и удобочитаемость кода);
- помогает при необходимости быстро вносить изменения в проект.
Кроме того благодаря наследованию система классов становится логически понятной и структурированной.

2) Принцип АБСТРАКЦИИ я также использую на этапе проектирования и, конечно, на этапе создания 
каждого класса. Этот принцип позволяет мне не тратить ресурсы (свое и пользователей программы) на 
внесение в программу лишней информации, которая затем не будет использоваться для решения задач
приложения (например, для приложения по расчету зарплаты сотрудников могут быть важны ставка, количество
отработанных часов и т.п., но при этом не важен, например, тот факт, есть ли у сотрудника домашнее животное
или сколько у него детей).

3) Принцип ИНКАПСУЛЯЦИИ я использую на нескольких этапах. 
Этот принцип позволяет объединить данные и методы в классе и скрыть реализацию
от пользователя. Он защищает от ошибок, несанкционированного доступа и изменения данных и делает 
работу программы проще для пользователя. 

- При получении задачи на создание приложения.
Я стараюсь сразу определить какой функционал должен быть доступен для пользователя и в зависимости от
этого продумываю, какие данные и методы должны быть доступны в пользовательском интерфейсе. 

- На этапе проектирования.
Я составляю список public методов, на основе функционала приложения, определенного на предыдущем этапе 
и список private (или protected - если нужно предусмотреть возможность их переопределения в классах-наследниках) 
методов, необходимых для реализации данного функционала. Эти методы относятся к "внутренней кухне", их
незачем вызвать извне.

- На этапе разработки.
Создаю private и public методы. Переменные экземпляра я делаю private и оборачиваю getter'ами и setter'ами.
чтобы пользователь не внес в них изменения, которые могут отразится на правильной работе программы или 
просто исказить информацию. При этом я могу, например, ограничить доступ к каим-то данным
группе пользователей, или обеспечить доступ по паролю или в setter прописать условие, при котором переданное 
значение можно внести в качестве значения данной переменной, что обеспечивает страховку от ошибок
пользователя (например, вес собаки не может быть отрицательным и т.п.) а также можно установить setter, в 
котором при изменении одного значения автоматически пересчитываются другие и добавить другую 
функциональность.

В случае работы над сложным приложением, я также могу разбить работу на логические части и сначала, например, 
разработать методы, отвечающие за пользовательский интерфейс, а потом продумать и разработать их 
релизацию с помощью private методов. 

- На этапе внесения изменений.
С помощью инкапсуляции я могу при необходимости доработать или изменить любой private метод, 
отвечающий за реализацию, а пользователь не узнает об этом и сможет спокойно продолжать использовать 
мое приложение или класс с помощью public методов.

4) Используя ПОЛИМОРФИЗМ я могу вызвать у экземпляров различных классов, реализующих общий интерфейс и,
например, объединенных, в какую-нибудь коллекцию (не обязательно), общий метод, обратившись к ним по 
переменной интерфейса. При этом у каждого экземпляра будет вызвана своя собственная реализация этого метода. 
И мне не нужно знать тип класса каждого экзмепляра или знать, как именно реализван мой метод в данном 
конкретном экземпляре. 

Принцип полиморфизма помогает мне, например, при создании приложений с реализацией паттерна 
"фабрика" (когда я не знаю заранее, какой класс будет создан, но на основе поступающих извне данных программа
сама создает экземпляр того или иного класса). 

Систему интерфейсов я также стараюсь продумывать на этапе проектирования. В дальнейшем я использую 
этот принцип также на этапе тестирования работы программы, обращаясь к экземплярам
раличных классов через переменную общего для них интерфейса. 